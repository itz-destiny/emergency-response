/**
 * @fileoverview Firestore Security Rules for the Rapid Response application.
 *
 * Core Philosophy:
 * This ruleset enforces a hybrid security model, combining user-based ownership for patients,
 * role-based access for admins, and shared access for emergency responses involving hospitals and responders.
 * Authorization independence is prioritized by denormalizing key IDs directly onto documents, avoiding costly `get()` calls.
 *
 * Data Structure:
 * - /patients/{patientId}:  Patient data, accessible only by the patient themselves.
 * - /hospitals/{hospitalId}: Hospital data, publicly readable.
 * - /hospitals/{hospitalId}/responders/{responderId}: Responder data, accessible by the associated hospital.
 * - /roles_admin/{adminId}: Admin role, granting broad access. Document existence confers admin privileges.
 * - /emergencyResponses/{emergencyResponseId}: Emergency response data, linking patients, hospitals, and responders.
 *   Access is controlled based on the IDs of the involved parties.
 *
 * Key Security Decisions:
 * - Listing of patients is restricted to the individual patient.
 * - Hospital data is publicly readable but writable only by admins (currently not implemented).
 * - Responders are scoped to their hospitals, with access controlled by hospital ID.
 * - Emergency Responses are accessible by patients, hospitals, and responders involved.
 *
 * Denormalization for Authorization:
 * - EmergencyResponse documents include patientId, hospitalId, and responderId to avoid `get()` calls when evaluating access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages patient data, ensuring only the patient can access their own information.
     * @path /patients/{patientId}
     * @allow (create) User with UID 'patient123' can create a document where patientId == 'patient123'.
     * @allow (get, update, delete) User with UID 'patient123' can get/update/delete a document where patientId == 'patient123'.
     * @deny (get, update, delete) User with UID 'otherUser' cannot get/update/delete a document where patientId == 'patient123'.
     * @principle Enforces document ownership for all operations.
     */
    match /patients/{patientId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(patientId);
      allow list: if isSignedIn() && isOwner(patientId);
      allow create: if isSignedIn() && isOwner(patientId);
      allow update: if isSignedIn() && isOwner(patientId) && resource != null;
      allow delete: if isSignedIn() && isOwner(patientId) && resource != null;
    }

    /**
     * @description Manages hospital data, making it publicly readable.
     *              Write access is currently not restricted (TODO: Implement Admin-Only writes).
     * @path /hospitals/{hospitalId}
     * @allow (get, list) Any user (or no user) can read hospital data.
     * @deny (create, update, delete) Any non-admin user cannot create/update/delete hospital data.
     * @principle Allows public read access while restricting write access (TODO: Implement Admin role).
     */
    match /hospitals/{hospitalId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation once the schema is updated with an admin role.
    }

    /**
     * @description Manages responder data within a specific hospital.
     *              Restricts access to members of that hospital.
     * @path /hospitals/{hospitalId}/responders/{responderId}
     * @allow (create) Any authenticated user can create a responder IF the hospitalId is valid
     * @allow (get, list) Any authenticated user can read the responder
     * @deny (update, delete) Non-hospital members cannot update/delete responder data.
     * @principle Scopes access to responders based on their associated hospital.
     */
    match /hospitals/{hospitalId}/responders/{responderId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Manages admin roles.  Existence of a document grants admin privileges.
     * @path /roles_admin/{adminId}
     * @allow (create) User can create their admin role (self-assignment).
     * @allow (get) Any authenticated user can check for the existence of an admin role.
     * @deny (update, delete) Only the admin can modify/delete their own role.
     * @principle Implements role-based access control (RBAC) using document existence.
     */
    match /roles_admin/{adminId} {
      function isOwner(adminId) {
        return request.auth.uid == adminId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isSignedIn() && isOwner(adminId);
      allow update: if isSignedIn() && isOwner(adminId) && resource != null;
      allow delete: if isSignedIn() && isOwner(adminId) && resource != null;
    }

    /**
     * @description Manages emergency response data.
     *              Access is granted to the patient, hospital, and responder involved.
     * @path /emergencyResponses/{emergencyResponseId}
     * @allow (get, list) Patient, Hospital or Responder can read the emergency response.
     * @allow (create) Patient, Hospital or Responder can create the emergency response.
     * @deny (update, delete) Only the involved parties can update/delete the response.
     * @principle Grants access based on involvement in the emergency response (patient, hospital, responder).
     */
    match /emergencyResponses/{emergencyResponseId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }
  }
}